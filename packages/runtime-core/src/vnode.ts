import {
  isArray,
  isFunction,
  isString,
  isObject,
  EMPTY_ARR,
  extend,
  PatchFlags
} from '@vue/shared'
import { ComponentInternalInstance, Data, SetupProxySymbol } from './component'
import { RawSlots } from './componentSlots'
import { ShapeFlags } from './shapeFlags'
import { isReactive } from '@vue/reactivity'
import { AppContext } from './apiApp'
import { SuspenseBoundary } from './suspense'

export const Fragment = __DEV__ ? Symbol('Fragment') : Symbol()
export const Text = __DEV__ ? Symbol('Text') : Symbol()
export const Comment = __DEV__ ? Symbol('Empty') : Symbol()
export const Portal = __DEV__ ? Symbol('Portal') : Symbol()
export const Suspense = __DEV__ ? Symbol('Suspense') : Symbol()

// 声明 VNodeTypes 类型
export type VNodeTypes =
  | string
  | Function
  | Object
  | typeof Fragment
  | typeof Portal
  | typeof Text
  | typeof Comment
  | typeof Suspense

type VNodeChildAtom<HostNode, HostElement> =
  | VNode<HostNode, HostElement>
  | string
  | number
  | boolean
  | null
  | void

export interface VNodeChildren<HostNode = any, HostElement = any>
  extends Array<
      | VNodeChildren<HostNode, HostElement>
      | VNodeChildAtom<HostNode, HostElement>
    > {}

export type VNodeChild<HostNode = any, HostElement = any> =
  | VNodeChildAtom<HostNode, HostElement>
  | VNodeChildren<HostNode, HostElement>

export type NormalizedChildren<HostNode = any, HostElement = any> =
  | string
  | VNodeChildren<HostNode, HostElement>
  | RawSlots
  | null

export interface VNode<HostNode = any, HostElement = any> {
  _isVNode: true
  type: VNodeTypes
  props: Record<any, any> | null
  key: string | number | null
  ref: string | Function | null
  children: NormalizedChildren<HostNode, HostElement>
  component: ComponentInternalInstance | null
  suspense: SuspenseBoundary<HostNode, HostElement> | null

  // DOM
  el: HostNode | null

//Anchor 对象： Anchor 对象表示 HTML 超链接。
// 在 HTML 文档中 <a> 标签每出现一次，就会创建 Anchor 对象。
// 锚可用于创建指向另一个文档的链接（通过 href 属性），或者创建文档内的书签（通过 name 属性）。
// 您可以通过搜索 Document 对象中的 anchors[] 数组来访问锚，或者使用 document.getElementById()。
  anchor: HostNode | null // fragment anchor
  target: HostElement | null // portal target

  // optimization only
  shapeFlag: number
  patchFlag: number
  dynamicProps: string[] | null
  dynamicChildren: VNode[] | null

  // application root node only
  appContext: AppContext | null
}

// Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).
const blockStack: (VNode[] | null)[] = []

// Open a block.
// This must be called before `createBlock`. It cannot be part of `createBlock`
// because the children of the block are evaluated before `createBlock` itself
// is called. The generated code typically looks like this:
//
//   function render() {
//     return (openBlock(),createBlock('div', null, [...]))
//   }
//
// disableTracking is true when creating a fragment block, since a fragment
// always diffs its children.
export function openBlock(disableTracking?: boolean) {
  blockStack.push(disableTracking ? null : [])
}

let shouldTrack = true

// Create a block root vnode. Takes the same exact arguments as `createVNode`.
// A block root keeps track of dynamic nodes within the block in the
// `dynamicChildren` array.
export function createBlock(
  type: VNodeTypes,
  props?: { [key: string]: any } | null,
  children?: any,
  patchFlag?: number,
  dynamicProps?: string[]
): VNode {
  // avoid a block with optFlag tracking itself
  shouldTrack = false
  const vnode = createVNode(type, props, children, patchFlag, dynamicProps)
  shouldTrack = true
  const trackedNodes = blockStack.pop()
  vnode.dynamicChildren =
    trackedNodes && trackedNodes.length ? trackedNodes : EMPTY_ARR
  // a block is always going to be patched
  trackDynamicNode(vnode)
  return vnode
}

export function isVNode(value: any): boolean {
  return value ? value._isVNode === true : false
}

// 创建虚拟DOM,VNode
export function createVNode(
  type: VNodeTypes,
  props: { [key: string]: any } | null = null,
  children: unknown = null,
  patchFlag: number = 0,  // 变化
  dynamicProps: string[] | null = null // 动态属性
): VNode {
  // class & style normalization.（class & style 序列化）
  if (props !== null) {
    // for reactive or proxy objects, we need to clone it to enable mutation.
    // todo...
    // 对于 reactive 或者 proxy 对象，我们需要克隆它来面对值改变的情况。
    // proxy objects（是指通过 new Proxy 实现的双向绑定对象？？？）对象
    // isReactive()-->返回的是 reactiveToRaw.has(value) || readonlyToRaw.has(value) 只读属性？？？computed？？？
    if (isReactive(props) || SetupProxySymbol in props) {
      // 克隆props，有点像jquery的extend方法
      props = extend({}, props) 
    }
    // class normalization only needed if the vnode isn't generated by
    // compiler-optimized code
    if (props.class != null && !(patchFlag & PatchFlags.CLASS)) {
      props.class = normalizeClass(props.class)
    }
    let { style } = props
    // 样式
    if (style != null) {
      // reactive state objects need to be cloned since they are likely to be mutated
      // 跟克隆 prop 同理
      if (isReactive(style) && !isArray(style)) {
        style = extend({}, style)
      }
      // 序列化 style，数组返回{下标：值}， 对象返回{key：value}
      props.style = normalizeStyle(style)
    }
  }

  // encode the vnode type information into a bitmap
  // 把 VNode 类型的信息编码成位图
  const shapeFlag = isString(type)
  // ShapeFlags VNode的type string => ELEMENT
    ? ShapeFlags.ELEMENT
    : isObject(type)
    // object => STATEFUL_COMPONENT
      ? ShapeFlags.STATEFUL_COMPONENT
      : isFunction(type)
      // function => FUNCTIONAL_COMPONENT
        ? ShapeFlags.FUNCTIONAL_COMPONENT
        : 0

  const vnode: VNode = {
    _isVNode: true,
    type,
    props,
    // key, ref 区分唯一
    key: (props && props.key) || null,
    ref: (props && props.ref) || null,
    children: null,
    component: null,
    suspense: null,
    el: null,
    // 锚点
    anchor: null,
    target: null,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null
  }
  // 序列化 children 
  // chilren 类型 ： TEXT_CHILDREN \ ARRAY_CHILDREN \ SLOTS_CHILDREN 
  normalizeChildren(vnode, children)

  // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  // 当前 VNode 的 patch 标识 说明当前 node 是否需要更新
  // 如果是 component node 是需要做 patch(补丁)，因为即使它不需要更新，它也需要将实例保存到下一个 vnode 上，以便之后可以正确的 unmounted.
  if (
    shouldTrack &&
    (patchFlag ||
      shapeFlag & ShapeFlags.STATEFUL_COMPONENT || // shapeFlag & ShapeFlags.STATEFUL_COMPONENT 按位运算 意思是当前的shapeFlag是STATEFUL_COMPONENT类型吗？（按位做与运算，只有当当前值 shapeFlag 和 ShapeFlags.STATEFUL_COMPONENT完全一致才能得到 true 的结果）
      shapeFlag & ShapeFlags.FUNCTIONAL_COMPONENT) // shapeFlag & ShapeFlags.FUNCTIONAL_COMPONENT 按位运算 意思是当前的shapeFlag是FUNCTIONAL_COMPONENT类型吗？
  ) {
    trackDynamicNode(vnode)
  }

  return vnode
}

// 跟踪 动态 VNode
function trackDynamicNode(vnode: VNode) {
  const currentBlockDynamicNodes = blockStack[blockStack.length - 1]
  if (currentBlockDynamicNodes != null) {
    currentBlockDynamicNodes.push(vnode)
  }
}

export function cloneVNode(vnode: VNode): VNode {
  return {
    _isVNode: true,
    type: vnode.type,
    props: vnode.props,
    key: vnode.key,
    ref: vnode.ref,
    children: vnode.children,
    target: vnode.target,
    shapeFlag: vnode.shapeFlag,
    patchFlag: vnode.patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,

    // these should be set to null since they should only be present on
    // mounted VNodes. If they are somehow not null, this means we have
    // encountered an already-mounted vnode being used again.
    component: null,
    suspense: null,
    el: null,
    anchor: null
  }
}

export function normalizeVNode(child: VNodeChild): VNode {
  if (child == null) {
    // empty placeholder
    return createVNode(Comment)
  } else if (isArray(child)) {
    // fragment
    return createVNode(Fragment, null, child)
  } else if (typeof child === 'object') {
    // already vnode, this should be the most common since compiled templates
    // always produce all-vnode children arrays
    return child.el === null ? child : cloneVNode(child)
  } else {
    // primitive types
    return createVNode(Text, null, child + '')
  }
}

export function normalizeChildren(vnode: VNode, children: unknown) {
  let type = 0
  if (children == null) {
    children = null
  } else if (isArray(children)) {
    type = ShapeFlags.ARRAY_CHILDREN
  } else if (typeof children === 'object') {
    type = ShapeFlags.SLOTS_CHILDREN
  } else if (isFunction(children)) {
    children = { default: children }
    type = ShapeFlags.SLOTS_CHILDREN
  } else {
    children = isString(children) ? children : children + ''
    type = ShapeFlags.TEXT_CHILDREN
  }
  vnode.children = children as NormalizedChildren
  vnode.shapeFlag |= type // that mean vnode.shapeFlag = vnode.shapeFlag | type
}

function normalizeStyle(
  value: unknown
): Record<string, string | number> | void {
  if (isArray(value)) {
    const res: Record<string, string | number> = {}
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeStyle(value[i])
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key]
        }
      }
    }
    return res
  } else if (isObject(value)) {
    return value
  }
}

export function normalizeClass(value: unknown): string {
  let res = ''
  if (isString(value)) {
    res = value
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      res += normalizeClass(value[i]) + ' '
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + ' '
      }
    }
  }
  return res.trim()
}

const handlersRE = /^on|^vnode/

export function mergeProps(...args: Data[]) {
  const ret: Data = {}
  extend(ret, args[0])
  for (let i = 1; i < args.length; i++) {
    const toMerge = args[i]
    for (const key in toMerge) {
      if (key === 'class') {
        ret.class = normalizeClass([ret.class, toMerge.class])
      } else if (key === 'style') {
        ret.style = normalizeStyle([ret.style, toMerge.style])
      } else if (handlersRE.test(key)) {
        // on*, vnode*
        const existing = ret[key]
        ret[key] = existing
          ? [].concat(existing as any, toMerge[key] as any)
          : toMerge[key]
      } else {
        ret[key] = toMerge[key]
      }
    }
  }
  return ret
}
